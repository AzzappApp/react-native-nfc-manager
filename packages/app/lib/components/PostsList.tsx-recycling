import range from 'lodash/range';
import { useCallback, useMemo, useState } from 'react';
import { useWindowDimensions } from 'react-native';
import { ScrollView } from 'react-native-gesture-handler';
import { graphql, usePaginationFragment } from 'react-relay';
import PostRenderer from '../components/PostRenderer';
import type {
  RecommandedPostsList_viewer$data,
  RecommandedPostsList_viewer$key,
} from '@azzapp/relay/artifacts/RecommandedPostsList_viewer.graphql';
import type { ReactElement } from 'react';
import type {
  StyleProp,
  ViewStyle,
  NativeScrollEvent,
  NativeSyntheticEvent,
  LayoutChangeEvent,
} from 'react-native';

type RecommandedPostsListProps = {
  viewer: RecommandedPostsList_viewer$key;
  canPlay: boolean;
  style?: StyleProp<ViewStyle>;
  ListHeaderComponent?: ReactElement;
};

// This is an attemps to Use recycling for post list with custom layout
// While this work it needs a lot of tweaking if we want to make it performant enough
// for the moment we will leave in the code without using it

const RecommandedPostsList = ({ viewer, style }: RecommandedPostsListProps) => {
  const [refreshing, setRefreshing] = useState(false);
  const { data, loadNext, refetch, hasNext, isLoadingNext } =
    usePaginationFragment(
      graphql`
        fragment RecommandedPostsList_viewer on Viewer
        @refetchable(queryName: "RecommandedPostsListQuery")
        @argumentDefinitions(
          after: { type: String }
          first: { type: Int, defaultValue: 50 }
        ) {
          recommandedPosts(after: $after, first: $first)
            @connection(key: "Viewer_recommandedPosts") {
            edges {
              node {
                id
                ...PostRendererFragment_post
                author {
                  ...PostRendererFragment_author
                }
                content
                media {
                  ratio
                }
              }
            }
          }
        }
      `,
      viewer,
    );

  const onRefresh = useCallback(() => {
    if (refreshing) {
      return;
    }
    setRefreshing(true);
    refetch(
      {},
      {
        // network-only cause flash of content
        fetchPolicy: 'store-and-network',
        onComplete() {
          //TODO handle errors
          setRefreshing(false);
        },
      },
    );
  }, [refetch, refreshing]);

  const onEndReached = useCallback(() => {
    if (!isLoadingNext && hasNext) {
      loadNext(50);
    }
  }, [isLoadingNext, hasNext, loadNext]);

  const postsLists = useMemo(
    () => data.recommandedPosts.edges?.map(edge => edge?.node ?? null) ?? [],
    [data.recommandedPosts.edges],
  );

  const { width: windowWidth } = useWindowDimensions();
  const [contentHeight, dataWithLayout] = useMemo(() => {
    const even: PostNodeType[] = [];
    const odd: PostNodeType[] = [];

    postsLists.forEach((item, index) => {
      if (!item) {
        console.log('no item for index ', index);
        return;
      }
      if (index % 2 === 0) {
        even.push(item);
      } else {
        odd.push(item);
      }
    });

    // window width - the 3 margin of 8px
    const itemWidth = (windowWidth - 24) / 2;
    let currentPosition = 0;
    const measureItem = (item: PostNodeType, isOdd: boolean) => {
      const layout = {
        left: isOdd ? itemWidth + 16 : 8,
        top: currentPosition,
        width: itemWidth,
        // media margin between next and media, text height
        height: itemWidth / item!.media.ratio + 5 + (item!.content ? 34 : 0),
      };
      //  margin with bottom
      currentPosition += layout.height + 8;
      return { item, layout };
    };
    const evenData = even.map(item => measureItem(item, false));
    let height = currentPosition;
    currentPosition = 0;
    const oddData = odd.map(item => measureItem(item, true));
    height = Math.max(height, currentPosition);
    return [height, [...evenData, ...oddData]];
  }, [postsLists, windowWidth]);

  const [currentBatch, setCurrentBatch] = useState(0);
  const [scrollViewHeight, setScrollViewHeight] = useState(0);
  const batchSize = scrollViewHeight;

  const onLayout = (e: LayoutChangeEvent) => {
    setScrollViewHeight(e.nativeEvent.layout.height);
  };

  const onScroll = (e: NativeSyntheticEvent<NativeScrollEvent>) => {
    const scrollPosition = e.nativeEvent.contentOffset.y;
    if (contentHeight - scrollPosition < scrollViewHeight * 2) {
      onEndReached();
    }

    setCurrentBatch(Math.floor(Math.max(scrollPosition, 0) / batchSize));
  };

  // the batch system works by determining a list of item
  // to display on 'page' of the scroll view and by moving the
  // page on the bottom and on top during scroll
  // since we always reuse the same key react-native should not
  // recreate view
  const items = useMemo(() => {
    const positions = range(currentBatch - 2, currentBatch + 2);
    const batchIndexes = [0, 0, 0, 0];

    const results: Array<{
      item: Exclude<PostNodeType, null>;
      layout: ViewStyle;
      key: string;
      currentLayoutPostion: number;
    }> = [];

    dataWithLayout.forEach(({ item, layout }) => {
      if (!item || !layout) {
        return null;
      }
      positions.forEach((position, index) => {
        if (position < 0) {
          return;
        }
        const currentLayoutPostion = position * batchSize;
        const nextLayoutPosition = (position + 1) * batchSize;
        const prefix = BATCHES[(2 + position) % 4];
        if (
          layout.top >= currentLayoutPostion &&
          layout.top < nextLayoutPosition
        ) {
          results.push({
            item,
            layout,
            key: `${prefix}-${batchIndexes[index]++}`,
            currentLayoutPostion,
          });
        }
      });
    });
    return results;
  }, [dataWithLayout, currentBatch, batchSize]);

  return (
    <ScrollView
      style={style}
      contentContainerStyle={{ height: contentHeight }}
      scrollEventThrottle={16}
      onScroll={onScroll}
      onLayout={onLayout}
    >
      {items.map(({ key, item, layout }) => (
        <PostRenderer
          key={key}
          post={item}
          width={(windowWidth - 24) / 2}
          author={item.author}
          small
          muted
          style={[{ position: 'absolute' }, layout]}
        />
      ))}
    </ScrollView>
  );
};

export default RecommandedPostsList;

type PostNodeType = Exclude<ItemType<EdgesType>, null>['node'];

type ItemType<T> = T extends ReadonlyArray<infer U> ? U : never;

type EdgesType = Exclude<
  RecommandedPostsList_viewer$data['recommandedPosts']['edges'],
  null
>;

const BATCHES = ['first', 'second', 'third', 'four'];
